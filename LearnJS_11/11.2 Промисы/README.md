# Promise 

<h2>Промисы</h2>

- [ ] `Промисы (Promises)` - это объекты, представляющие асинхронные операции. Они используются для обработки асинхронных действий, таких как запросы к серверу, чтение файлов или выполнение долгих вычислений, где результат неизвестен сразу.

- [ ] Промисы имеют три состояния: `ожидание (pending)`, `выполнено (fulfilled)` и `отклонено (rejected)`.

- [ ] Промисы обеспечивают `цепочки обработки (chaining)`, которые позволяют последовательно выполнять операции после завершения асинхронных действий.

```javascript
  let promise = new Promise(function(resolve, reject) {
    // функция-исполнитель (executor)
  });
```

<br>

  - [x] Функция, переданная в конструкцию `new Promise` - это `исполнитель (executor)`. Она должна содержать «создающий» код, который когда-нибудь создаст результат.
  - [x] Когда он получает результат, сейчас или позже – не важно, он должен вызвать один из этих колбэков:

    + `resolve(value)` — если работа завершилась успешно, с результатом `value`.
    + `reject(error)` — если произошла ошибка, `error` – объект ошибки. 

  <br>

  - [x] У объекта `promise`, возвращаемого конструктором `new Promise`, есть внутренние свойства:

    + `state` — вначале `"pending" («ожидание»)`, потом меняется на `"fulfilled" («выполнено успешно»)` при вызове `resolve` или на `"rejected" («выполнено с ошибкой»)` при вызове `reject`.
    + `result` — вначале `undefined`, далее изменяется на `value` при вызове `resolve(value)` или на `error` при вызове `reject(error)`.
       
    ![image](https://github.com/acidshotgun/learn-js-vanilla/assets/117285472/b180dfdf-c4b3-4ea9-8689-50bfa96e4226)

  <br>

  - [x] Пример, при котором возвращается переданное сообщение либо ошибка. Асинхронный код, ожидаем результат через опр. время.

  ```javascript
    const showMessage = (message) => {
      /*
        Ф-я возвращает промис
        Внутри исполнитель (executor)
        В зависимости от условия вызывает resolve|reject
      */
      return new Promise((resolve, reject) => {
        if (message.length < 10) {
          // Выполнение с ошибкой 
          setTimeout(() => {
            reject(new Error("Ошибка! Короткое сообщение!"));
          }, 500);
        } else {
          // Успешное выполнение
          setTimeout(() => {
            resolve(message);
          }, 2000);
        }
      });
    };
    
    /*
      Вызов showMessage() вернет промис, который нужно обработать
      Используется then|catch (finally - опционально)
    */
    showMessage("Привет! Теперь это длинное сообщение")
      .then((res) => console.log(res))
      .catch((error) => console.log(error))
      .finally(() => console.log("Промис завершен."));
  ```

<hr>
<br>
<br>

<h2>Важности</h2>

![image](https://github.com/acidshotgun/learn-js-vanilla/assets/117285472/eb9b11c9-8a42-4944-85dc-40e3df2b3b20)

![image](https://github.com/acidshotgun/learn-js-vanilla/assets/117285472/5685492d-1a4d-4aca-89f2-dcbefd82eb5f)

![image](https://github.com/acidshotgun/learn-js-vanilla/assets/117285472/507c9b19-8150-4a1f-ab4f-beefc0617b6e)

<hr>
<br>
<br>

<h2>Потребители: then, catch</h2>

- [ ] с помощью методов `.then` и `.catch` можно подписаться на ожидаемые события.

<br>

<h3>then</h3>

- [ ] Вызвается в случае успешного выполнения `промиса` - `resolve`

```javascript
  promise.then(
    function(result) { /* обработает успешное выполнение */ },
    function(error) { /* обработает ошибку */ }
  );
```

+ Первый аргумент метода `.then` – функция, которая выполняется, когда промис переходит в состояние «выполнен успешно», и получает результат.

+ `.then` - так же всегда возвращает промис. Поэтому можно делать `цепочку` (Но чтобы передавать именно результат обработанного промиса дальше, то этот результат нужно `return`.

  ```javascript
    new Promise((resolve) => {
      setTimeout(() => {
        resolve("hello world");
      }, 1000);
      })
        .then((res) => {
          console.log(res.toUpperCase());
          // Прокидываем результат дальше
          // Чтобы с ним можно было работать
          return res;
        })
        .then((res) => console.log(res.toLowerCase()));
      
      //||||||||||||||||
      new Promise((resolve) => {
        setTimeout(() => {
          resolve("hello world");
        }, 1000);
      })
        .then((res) => {
          console.log(res.toUpperCase());
        })
        // Тут будет ошибка
        // Промис передается дальше по цепочке, но тк результат не передан - мы читаем undefined
        .then((res) => console.log(res.toLowerCase()));
  ```

+ Второй аргумент `.then` (НЕ ОБЯЗАТЕЛЕН, ТК ЕСТЬ .catch) – функция, которая выполняется, когда промис переходит в состояние «выполнен с ошибкой», и получает ошибку.

<br>

<h3>catch</h3>

- [ ] Вызвается в случае ошибки выполнения `промиса` - `reject`

<br>

<h3>finally</h3>

- [ ] Срабатывает по завершении промиса
- [ ] Идея `finally` состоит в том, чтобы настроить обработчик для выполнения очистки/доведения после завершения предыдущих операций. Например, остановка индикаторов загрузки, закрытие больше не нужных соединений и т.д.

```javascript
  new Promise((resolve, reject) => {
    /* сделать что-то, что займёт время, и после вызвать resolve или может reject */
  })
    // выполнится, когда промис завершится, независимо от того, успешно или нет
    .finally(() => остановить индикатор загрузки)
    // таким образом, индикатор загрузки всегда останавливается, прежде чем мы продолжим
    .then(result => показать результат, err => показать ошибку)
```
