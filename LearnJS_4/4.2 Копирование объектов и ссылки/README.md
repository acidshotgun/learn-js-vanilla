# Копирование объектов и ссылки

- [ ] Одно из фундаментальных отличий объектов от примитивов заключается в том, что `объекты хранятся и копируются «по ссылке»`, тогда как `примитивные значения: строки, числа, логические значения и т.д. – всегда копируются «как целое значение»`.

![](https://github.com/acidshotgun/learn-js-vanilla/blob/master/LearnJS_4/4.2%20%D0%9A%D0%BE%D0%BF%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2%20%D0%B8%20%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B8/img/obj1.jpg)

<br>
<br>

- [x] ***Переменная, которой присвоен объект, хранит не сам объект, а его `«адрес в памяти»` – другими словами, `«ссылку» на него`.***

![](https://github.com/acidshotgun/learn-js-vanilla/blob/master/LearnJS_4/4.2%20%D0%9A%D0%BE%D0%BF%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2%20%D0%B8%20%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B8/img/obj2.jpg)

<br>
<br>

- [x] ***При копировании переменной объекта `копируется ссылка`, но `сам объект не дублируется`.***

![](https://github.com/acidshotgun/learn-js-vanilla/blob/master/LearnJS_4/4.2%20%D0%9A%D0%BE%D0%BF%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2%20%D0%B8%20%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B8/img/obj3.jpg)

  + Мы можем использовать `любую переменную` для доступа к объекту и изменения его содержимого:
  + Это как если бы у нас был шкафчик с двумя ключами. И один шкафчик можно открывать этими двумя ключами.

```javascript
  // Создание объекта
  const mainObj = {
    name: "sasha",
    age: 15,
  };
  
  // Копирование gj ccskrt
  // Но на самом деле это лишь еще одни ссылка на объект в памяти
  const secondObj = mainObj;
  
  // Обратившись по новой ссылке к объекту
  // Мы добавили св-во в объект на который ссылаются переменные
  secondObj.isAdmin = true;
  
  /* 
    Мы не копируем объект и не добавляем в копию новые св-ва
    Это ссылки, по которым мы получаем доступ к самому объекту в памяти
  */
  console.log(mainObj); // - { name: 'sasha', age: 15, isAdmin: true }
  console.log(secondObj); // - { name: 'sasha', age: 15, isAdmin: true }

```

<hr>
<br>
<br>

<h2>Сравнение по ссылке</h2>

- [ ] Два объекта равны только в том случае, если это один и тот же объект.

  + Например, здесь `a` и `b` ссылаются на один и тот же объект, поэтому они равны:
     
  ```javascript
    let a = {};
    let b = a; // копирование по ссылке
    
    console.log( a == b ); // true, обе переменные ссылаются на один и тот же объект
    console.log( a === b ); // true
  ```

  + И здесь два независимых объекта не равны, даже если они выглядят одинаково (оба пусты):
     
  ```javascript
    let a = {};
    let b = {}; // два независимых объекта
    
    console.log( a == b ); // false
  ```

- [ ] Для сравнений типа `obj1 >` obj2 или для сравнения с примитивом `obj == 5` объекты преобразуются в `примитивы`.

<hr>
<br>
<br>

<h2>Клонирование и объединение, Object.assign</h2>

- [ ] Копирование объектной переменной создаёт ещё одну ссылку на тот же объект.
- [ ] Если нужно копировать объект, то это выполнимо, но немного сложнее, потому что в JavaScript для этого нет встроенного метода.

<br>

- [ ] Для копирования объекта нужно создать новый объект и воспроизвести структуру существующего, перебрав его свойства и скопировав их на примитивном уровне при помощи `for...in`.

```javascript
  /*
  ф-я, которая будет принимать объект как аргумент и создавать копию
  возвращает копию объекта
  */
  const objectCopy = (obj) => {
    // Создание пустого объекта
    const newObj = {};
  
    // Копирование свойста с for...in
    for (let key in obj) {
      newObj[key] = obj[key];
    }

    // Возвращаем зн-е - это скопированный объект
    return newObj;
  };
  
  const testObj = {
    name: "Sasha",
    age: 15,
  };
  
  // Создаем переменную
  // И помещаем в нее выражение, которое возвращает функция копирования
  const testObjCopy = objectCopy(testObj);
  
  // Изменяем копию
  testObjCopy.numbers = [1, 2, 3];
  
  console.log(testObj); // - { name: 'Sasha', age: 15 }
  console.log(testObjCopy); // - { name: 'Sasha', age: 15, numbers: [ 1, 2, 3 ] }

// В итоге имеем копию объекта которая независима.
```

<br>

- [ ] Также мы можем использовать для этого метод `Object.assign`.

```javascript
  Object.assign(dest, [src1, src2, src3...])
```

  + Первый аргумент dest — целевой объект (куда копируем).
  + Остальные аргументы src1, ..., srcN (может быть столько, сколько необходимо) являются исходными объектами (что копируется)
  + Метод копирует свойства всех исходных объектов src1, ..., srcN в целевой объект dest. Другими словами, свойства всех аргументов, начиная со второго, копируются в первый объект.
  + Возвращает объект dest.

```javascript
  let user = { name: "John" };

  let permissions1 = { canView: true };
  let permissions2 = { canEdit: true };
  
  // копируем все свойства из permissions1 и permissions2 в user
  Object.assign(user, permissions1, permissions2);
  
  // теперь user = { name: "John", canView: true, canEdit: true }
```

  + Если скопированное имя свойства уже существует, оно будет перезаписано.

<br>

- [x] Мы также можем использовать `Object.assign` для замены цикла `for..in` для простого клонирования:

```javascript
  const testObj = {
    name: "Sasha",
    age: 15,
  };

  // Он копирует все свойства user в пустой объект и возвращает его.
  const testObjCopy = Object.assign({}, testObj);
  
  testObjCopy.isAdmin = true;
  
  console.log(testObjCopy); // - { name: 'Sasha', age: 15, isAdmin: true }

```

<hr>
<br>
<br>

<h2>Вложенное клонирование</h2>

- [ ] Объекты клонируются поверхностно. Т.е. если в объекте есть вложенные объекты, то при клонировании будут клонироваться лишь ссылки на эти объекты в памяти.
- [ ] `Вложенные объекты` - это тоже ссылки на объекты в памяти
      
<br>

- [ ] Чтобы исправить это, мы должны использовать цикл клонирования, который проверяет каждое значение user[key] и, если это объект, тогда также копирует его структуру. Это называется `«глубоким клонированием»`.

  + Мы можем реализовать глубокое клонирование, используя рекурсию. Или, чтобы не изобретать велосипед заново, возьмите готовую реализацию, например `_.cloneDeep(obj)` из библиотеки `JavaScript lodash`.
  + Также мы можем использовать глобальный метод `structuredClone()`, который позволяет сделать полную копию объекта.
     
<br>

- [ ] Вариант глубокого клонирования с `JSON.parse(JSON.stringify(testObj))`. Делает глубокую копию. Недостатки:

    + Не клонирует функции
    + Не клонирует объекты с нестандартными св-ми

```javascript
  // Объект с вложенным св-м
  const testObj = {
    name: "Sasha",
    age: 15,
    size: {
      width: 50,
      height: 50,
    },
  };
  
  // Клонирорвание
  const clone = JSON.parse(JSON.stringify(testObj));
  
  // Изменяем копию
  clone.size.border = 2;
  
  console.log(testObj); // - { name: 'Sasha', age: 15, size: { width: 50, height: 50 } }
  console.log(clone); // - { name: 'Sasha', age: 15, size: { width: 50, height: 50, border: 2 } }
```
