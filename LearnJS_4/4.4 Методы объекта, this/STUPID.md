# ТУТ БУДУТ ПРИМЕРЫ ЗАДАЧЕК С THIS, НАДО КОТОРЫМИ Я ТУПИЛ. (ДЛЯ ПОНИМАНИЯ)

<h2>ЗАДАЧА 1</h2>

- [ ] Если вызвать `this` вне объекта, то он всегда `undefined (для строгого режима)` и `window/глобал (в нестрогом)`
      
- [ ] В этом примере два варианта:
      
    + `undefined` для сторого режима
    + `window` для нестрогого режима

```javascript
  function someFunc() {
    console.log(this);
  }
  
  someFunc();
```

<hr>
<br>
<br>

<h2>ЗАДАЧА 2</h2>

- [ ] Контекст вызова всегда напрямую зависит от того, где вызывается `this`.

  + Еще раз - `this` вне объекта = `undefined (строгий режим)` и `window (нестрогий режим)`
  + Вызывая метод `obj.method()` напрямую - контекстом будет являться сам объект.
  + Передав в переменную `func` ссылку на метод объекта => мы будем вызывать его уже вне объекта и контекст будет теряться. И таким образом будет работать принцип вызова `this` вне объектов.
     
  <br>

  + Грубо говоря мы вызваем метод объекта ВНЕ этого самого объекта.

```javascript
  const obj = {
    name: "какойта объект",
    method: function () {
      console.log(this);
    },
  };
  
  obj.method(); // { name: 'какойта объект', method: [Function: method] }
  
  // const func = obj.method.bind(obj);
  const func = obj.method;
  func(); // window / undefined
```

![image](https://github.com/acidshotgun/learn-js-vanilla/assets/117285472/5da55ce4-571e-4ff3-ba06-d9e3afe09466)

+ если функция вызывается вне контекста объекта или ее ссылка сохраняется в переменной и вызывается оттуда, контекст может быть потерян

<br>
<br>

<h3>+ Обратный пример</h3>

- [ ] Это обратный пример задачи 2 (выше)

 + В этом примере создается новый объект `anotherObj` со св-м. В нем создается метод, в который передается так-же ссылка на метод `method()` из первого объекта `obj`.
 + В отличии от первого примера - `method()` присвоенный по ссылке в момент вызова у нового объекта будет получать контекст объекта `anotherObj`. Таким образом в этом случае вызвав `anotherObj.method()` `this` получит контекст объекта `anotherObj` и будет иметь доступ к его св-м.

 <br>

 + ПРИМ. этом пример того, что контекст `this` присваевается именно в момент вызова метода. И `this` изначально никак не зафиксирован.
 + ПОМНИТЬ!

```javascript
      const obj = {
        prop: "I'm a property",
        method: function () {
          console.log(this.prop);
        },
      };
      
      const anotherObj = {
        prop: "I'm another property",
      };
      
      anotherObj.method = obj.method;
      
      anotherObj.method(); // "I'm another property"

```

<hr>
<br>
<br>

<h2>ЗАДАЧА 3</h2>

- [ ] Аналогичный прошлым пример. Показывает опять, что контекст `this` определяется в момент вызова метода.

+ В примере есть фенкция, которая выводит в лог `this.name`, которая казалось бы должна иметь `undefined`
+ Но эту функцию мы присваиваем объектам в кач-ве методо по ссылкам.
+ Соотв после вызова этих методов, контекст для них будет определен и равен их объектам.

```javascript
      function sayName() {
        console.log(this.name);
      }
      
      const obj1 = {
        name: "Object 1",
      };
      
      const obj2 = {
        name: "Object 2",
      };
      
      obj1.say = sayName;
      obj2.say = sayName;
      
      obj1.say(); // Object 1
      obj2.say(); // Object 2
```

<hr>
<br>
<br>

# СТРЕЛОЧНЫЕ ФУНКЦИИ

- [x] В отличии от `function decloration`, в которых контекст `this` объявляется в момент вызова метода, в `стрелочных функциях` контекст `this` фиксируется в момент объявления и всегда будет равен его изначальному окружению.

<h2>ЗАДАЧА 1</h2>

+ В этом примере объявляется `стрелочная ф-я func()`, которая выводит в консоль `this`. И контекст этого `this` будет зафиксирован в момент объявления ф-ии (а не в момент ее вызова, как у `function decloration`)
+ Метод `obj1.method()`, внутри вызывает внешнюю `стрелочную ф-ю func()`, которая выводит в консоль `this`.

<br>

+ Изначально может показаться, что `func()` внутри `obj1.method()` будет иметь в кач-ве контекста - объект `obj1`. Тк вызывается внутри `function decloration`.
+ НО! Поскольку у `стрелочной ф-ии` контекст привязывается в момент объявления - то и где бы метод не был вызван, КОНТЕКСТ ВСЕГДА БУДЕТ ОДИН (который объявлен в момент создания). 

```javascript
      const func = () => {
        console.log(this);
      };
      
      const obj1 = {
        name: "Object 1",
        method: function () {
          func();
        },
      };
      
      obj1.method(); // window, тк контекст на момент объявления - это global/window
```
