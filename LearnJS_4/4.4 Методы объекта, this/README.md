# Методы объекта, "this"

- [ ] Объекты обычно создаются, чтобы представлять сущности реального мира, будь то пользователи, заказы и так далее:

- [ ] И так же, как и в реальном мире, пользователь может совершать действия: выбирать что-то из корзины покупок, авторизовываться, выходить из системы, оплачивать и т.п. Такие действия в JavaScript представлены функциями в свойствах.

```javascript
  const user = {
    name: "Sasha",
    age: 20,
    sayHi() {
      console.log("Привет");
    },
  };
  
  user.sayHi(); // Привет!

 // Пользователь теперь умеет здороваться
```

  + Функцию, которая является свойством объекта, называют `методом` этого объекта.

<br>

- [x] Когда мы пишем наш код, используя объекты для представления сущностей реального мира, – это называется `объектно-ориентированным программированием` или сокращённо: «`ООП`».

<br>

  <h3>Сокращённая запись метода</h3>

  + Нужно отметить, что эти две записи не полностью эквивалентны. Есть тонкие различия, связанные с наследованием объектов (что будет рассмотрено позже),

  ```javascript
    // эти объекты делают одно и то же

user = {
  sayHi: function() {
      console.log("Привет");
    }
  };
  
  // сокращённая запись выглядит лучше, не так ли?
  user = {
    sayHi() { // то же самое, что и "sayHi: function(){...}"
      console.log("Привет");
    }
  };
  ```

<hr>
<br>
<br>

<h2>Ключевое слово «this» в методах</h2>

- [ ] Для доступа к информации внутри объекта метод может использовать ключевое слово `this`.
- [x] Значение `thi`s – это `объект «перед точкой»`, который используется для вызова метода. 

```javascript
    let user = {
      name: "Bob",
      age: 20,
      sayHi() {
        console.log(`Привет, я - ${this.name}`);
      },
    };

    userCopy.sayHi(); // - Привет, я - Bob
```

<br>

  + Технически также возможно получить доступ к объекту без ключевого слова `this`, обратившись к нему через внешнюю переменную (в которой хранится ссылка на этот объект):

  ```javascript
    let user = {
      name: "John",
      age: 30,
    
      sayHi() {
        alert(user.name); // "user" вместо "this"
      }
    
    };
  ```

  + Но такой код ненадёжен. Если мы решим скопировать ссылку на объект user в другую переменную, например, `admin = user`, и перезапишем переменную `user` чем-то другим, тогда будет осуществлён доступ к неправильному объекту при вызове метода из `admin`.

  ```javascript
    let user = {
      name: "John",
      age: 30,
    
      sayHi() {
        alert( user.name ); // приведёт к ошибке
      }
    
    };
    
    
    let admin = user;
    user = null; // перезапишем переменную для наглядности, теперь она не хранит ссылку на объект.
    
    admin.sayHi(); // TypeError: Cannot read property 'name' of null
  ```

  + Если бы мы использовали `this.name` вместо `user.name` внутри `alert`, тогда этот код бы сработал.

<hr>
<br>
<br>

<h2>«this» не является фиксированным</h2>

- [ ] В JavaScript ключевое слово `«this»` ведёт себя иначе, чем в большинстве других языков программирования. Его можно использовать в любой функции, даже если это не метод объекта.

```javascript
  // Тут нет ошибка
  function sayHi() {
    console.log( this.name );
  }
```

<br>

- [x] ***Значение `this` вычисляется во время выполнения кода, в зависимости от контекста.***

```javascript
  /*
    Например, здесь одна и та же функция назначена двум разным объектам и имеет различное значение «this» в вызовах:
  */

  let user = { name: "John" };
  let admin = { name: "Admin" };
  
  function sayHi() {
    alert( this.name );
  }
  
  // используем одну и ту же функцию в двух объектах
  user.f = sayHi;
  admin.f = sayHi;
  
  // эти вызовы имеют  разное значение this
  // "this" внутри функции - это объект "перед точкой"
  user.f(); // John  (this == user)
  admin.f(); // Admin  (this == admin)
  
  admin['f'](); // Admin (нет разницы между использованием точки или квадратных скобок для доступа к объекту)
```

  + Правило простое: если вызывается obj.f(), то во время вызова f, `this` – это obj. Так что, в приведённом выше примере это либо user, либо admin.

<br>

![image](https://github.com/acidshotgun/learn-js-vanilla/assets/117285472/d51766b4-cc5b-4e77-9d0c-59d73651d7a7)

![image](https://github.com/acidshotgun/learn-js-vanilla/assets/117285472/061c1755-a3a6-4d32-b6e0-48fd53e5fc33)

<hr>
<br>
<br>

<h2>У стрелочных функций нет «this»</h2>

![image](https://github.com/acidshotgun/learn-js-vanilla/assets/117285472/db279c66-e323-4cfb-83af-72eb6ac13ced)
