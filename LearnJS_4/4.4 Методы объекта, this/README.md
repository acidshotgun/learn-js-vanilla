# Методы объекта, "this"

- [ ] Объекты обычно создаются, чтобы представлять сущности реального мира, будь то пользователи, заказы и так далее:

- [ ] И так же, как и в реальном мире, пользователь может совершать действия: выбирать что-то из корзины покупок, авторизовываться, выходить из системы, оплачивать и т.п. Такие действия в JavaScript представлены функциями в свойствах.

```javascript
  const user = {
    name: "Sasha",
    age: 20,
    sayHi() {
      console.log("Привет");
    },
  };
  
  user.sayHi(); // Привет!

 // Пользователь теперь умеет здороваться
```

  + Функцию, которая является свойством объекта, называют `методом` этого объекта.

<br>

- [x] Когда мы пишем наш код, используя объекты для представления сущностей реального мира, – это называется `объектно-ориентированным программированием` или сокращённо: «`ООП`».

<br>

  <h3>Сокращённая запись метода</h3>

  + Нужно отметить, что эти две записи не полностью эквивалентны. Есть тонкие различия, связанные с наследованием объектов (что будет рассмотрено позже),

  ```javascript
    // эти объекты делают одно и то же

user = {
  sayHi: function() {
      console.log("Привет");
    }
  };
  
  // сокращённая запись выглядит лучше, не так ли?
  user = {
    sayHi() { // то же самое, что и "sayHi: function(){...}"
      console.log("Привет");
    }
  };
  ```

<hr>
<br>
<br>

<h2>Ключевое слово «this» в методах</h2>

- [ ] Для доступа к информации внутри объекта метод может использовать ключевое слово `this`.
- [x] Значение `thi`s – это `объект «перед точкой»`, который используется для вызова метода.
- [x] `this` в JavaScript является `ссылкой на текущий контекст выполнения кода`. В объектах или классах this обычно ссылается на объект, `в контексте которого вызывается функция или метод`. 

```javascript
    let user = {
      name: "Bob",
      age: 20,
      sayHi() {
        console.log(`Привет, я - ${this.name}`);
      },
    };

    userCopy.sayHi(); // - Привет, я - Bob
```

<br>

  + Технически также возможно получить доступ к объекту без ключевого слова `this`, обратившись к нему через внешнюю переменную (в которой хранится ссылка на этот объект):

  ```javascript
    let user = {
      name: "John",
      age: 30,
    
      sayHi() {
        alert(user.name); // "user" вместо "this"
      }
    
    };
  ```

  + Но такой код ненадёжен. Если мы решим скопировать ссылку на объект user в другую переменную, например, `admin = user`, и перезапишем переменную `user` чем-то другим, тогда будет осуществлён доступ к неправильному объекту при вызове метода из `admin`.

  ```javascript
    let user = {
      name: "John",
      age: 30,
    
      sayHi() {
        alert( user.name ); // приведёт к ошибке
      }
    
    };
    
    
    let admin = user;
    user = null; // перезапишем переменную для наглядности, теперь она не хранит ссылку на объект.
    
    admin.sayHi(); // TypeError: Cannot read property 'name' of null
  ```

  + Если бы мы использовали `this.name` вместо `user.name` внутри `alert`, тогда этот код бы сработал.

<hr>
<br>
<br>

<h2>«this» не является фиксированным</h2>

- [ ] В JavaScript ключевое слово `«this»` ведёт себя иначе, чем в большинстве других языков программирования. Его можно использовать в любой функции, даже если это не метод объекта.

```javascript
  // Тут нет ошибка
  function sayHi() {
    console.log( this.name );
  }
```

<br>

- [x] ***Значение `this` вычисляется во время выполнения кода, в зависимости от контекста.***

```javascript
  /*
    Например, здесь одна и та же функция назначена двум разным объектам и имеет различное значение «this» в вызовах:
  */

  let user = { name: "John" };
  let admin = { name: "Admin" };
  
  function sayHi() {
    alert( this.name );
  }
  
  // используем одну и ту же функцию в двух объектах
  user.f = sayHi;
  admin.f = sayHi;
  
  // эти вызовы имеют  разное значение this
  // "this" внутри функции - это объект "перед точкой"
  user.f(); // John  (this == user)
  admin.f(); // Admin  (this == admin)
  
  admin['f'](); // Admin (нет разницы между использованием точки или квадратных скобок для доступа к объекту)
```

  + Правило простое: если вызывается obj.f(), то во время вызова f, `this` – это obj. Так что, в приведённом выше примере это либо user, либо admin.

<br>

![image](https://github.com/acidshotgun/learn-js-vanilla/assets/117285472/d51766b4-cc5b-4e77-9d0c-59d73651d7a7)

![image](https://github.com/acidshotgun/learn-js-vanilla/assets/117285472/061c1755-a3a6-4d32-b6e0-48fd53e5fc33)

<hr>
<br>
<br>

<h2>У стрелочных функций нет «this»</h2>

![image](https://github.com/acidshotgun/learn-js-vanilla/assets/117285472/db279c66-e323-4cfb-83af-72eb6ac13ced)

<hr>
<br>
<br>

<h2>Цепочка вызова</h2>

- [ ] Распространенной практикой в JS `(объекты и классы)` `цепочка вызовов` такого плана:

```javascript
  ladder.up().up().down().showStep().down().showStep();


  // Вместо последовательного вызова
  ladder.up();
  ladder.up();
  ladder.down();
  ladder.showStep(); // 1
  ladder.down();
  ladder.showStep(); // 0
```

- [ ] Для того, чтобы такая цепочка работала - каждый метод должен возвращать сам объект => `this контекст`. Тем самым каждый метод помимо возможных действий возвращает собственный объект, передавая дальше и таким образом возможно выполнять цепочку методов последовательно друг за другом:

```javascript
  /*
    В этом примере методы как раз и возвращают this, контекст которого, на момент вызова метода будет сам объект.
    Таким образом каждый последующий метод работает с результатом предыдущего => те сам объект
  */
  
  let ladder = {
    step: 0,
    up() {
      this.step++;
      return this;
    },
    down() {
      this.step--;
      return this;
    },
    showStep: function () {
      // показывает текущую ступеньку
      console.log(this.step);
      return this;
    },
  };
  
  ladder.up().up().down().showStep().down().showStep();
```


<hr>
<br>
<br>

<h2>ИТОГ ПО `THIS`</h2>

<h3>В методах объекта:</h3>

- [x] Контекст `this` на момент создания объекта - это `Window (JS)` и `Global (Node.js)`.
- [x] Контекст `this` у объектов определяется в момент вызова функции / метода. Т.е. в момент выполнения кода. При вызова метода у объекта, контекст `this` будет привязан к самому объекту.

```javascript
  const hui = {
    name: "Apple",
    age: this.name, // тут undefined, тк конекст this - глобал
    showThis() {
      console.log(this); // тут контекст this - это объект сам hui
    },
  };
```

<br>

<h3>В глобальной области видимости или вне методов объекта:</h3>

- [x] Если `this` используется вне методов объекта или в глобальной области видимости, то по умолчанию `this` ссылается на `глобальный объект (Window в браузере, Global в Node.js)`. Или this будет равен undefined в строгом режиме.

```javascript
  function someFunc() {
    console.log(this); // контекст this - global
  }
  
  someFunc();
```

<br>

<h3>Общее:</h3>

  + Функции, которые находятся в свойствах объекта, называются «методами».
  + Методы позволяют объектам «действовать»: object.doSomething().
  + Методы могут ссылаться на объект через this.
    
- [ ] Значение `this` определяется во время исполнения кода.

  + При объявлении любой функции в ней можно использовать `this`, но этот `this` не имеет значения до тех пор, пока функция не будет вызвана.
  + Функция может быть скопирована между объектами (из одного объекта в другой).
  + Когда функция вызывается синтаксисом «метода» – object.method(), значением `this` во время вызова является `object`.
    
- [ ] Также ещё раз заметим, что стрелочные функции являются особенными – у них нет `this`. Когда внутри стрелочной функции обращаются к `this`, то его значение берётся извне.
