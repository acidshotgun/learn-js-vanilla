# Тип данных Symbol

- [ ] По спецификации, в качестве ключей для свойств объекта могут использоваться только строки или символы. Ни числа, ни логические значения не подходят, разрешены только эти два типа данных.

<hr>
<br>
<br>

<h2>Символы</h2>

- [ ] `«Символ»` представляет собой уникальный идентификатор.

    + Создаются новые символы с помощью функции `Symbol()`.
    + При создании, символу можно дать описание (также называемое имя), в основном использующееся для отладки кода.

    ```javascript
      // Создаём символ id с описанием (именем) "id"
      let id = Symbol("id");
    ```

<br>

- [ ] `Символы` гарантированно уникальны.

    + Даже если мы создадим множество символов с одинаковым описанием, это всё равно будут разные символы. Описание – это просто метка, которая ни на что не влияет.
    + Например, вот два символа с одинаковым описанием – но они не равны:

    ```javascript
      let id1 = Symbol("id");
      let id2 = Symbol("id");
      
      alert(id1 == id2); // false
    ```

<br>

![image](https://github.com/acidshotgun/learn-js-vanilla/assets/117285472/e877dd50-c246-459d-b319-a2116fcbdc1e)

<hr>
<br>
<br>

<h2>«Скрытые» свойства</h2>

- [ ] Символы позволяют создавать «скрытые» свойства объектов, к которым нельзя нечаянно обратиться и перезаписать их из других частей программы.
      
    + Например, мы работаем с объектами `user`, которые принадлежат стороннему коду. Мы хотим добавить к ним идентификаторы.
    + Используем для этого символьный ключ:
     
    ```javascript
      let user = {
        name: "Вася"
      };
      
      let id = Symbol("id");
      
      user[id] = 1;
      
      alert( user[id] ); // мы можем получить доступ к данным по ключу-символу
    ```

    ![image](https://github.com/acidshotgun/learn-js-vanilla/assets/117285472/dec333ca-4e64-4fc6-8f3d-c797ca920e65)

    + не перезаписывает id а создает уникальный символ

    ```javascript
        let obj = {
            name: "Bob",
            id: "1234"
        }
        
        let id = Symbol("id");
        
        obj[id] = "id_12345566"
        
        console.log(obj) // { name: 'Bob', id: '1234', [Symbol(id)]: 'id_12345566' }
    ```

<br>
<br>
<br>

  <h3>+ Символы в литеральном объекте</h3>

  - [ ] Если мы хотим использовать `символ` при `литеральном объявлении объекта {...}`, его необходимо заключить в квадратные скобки.

  ```javascript
    let id = Symbol("id");
    
    let user = {
      name: "Вася",
      [id]: 123 // просто "id: 123" не сработает
    };
  ```
  + Это вызвано тем, что нам нужно использовать значение переменной `id` в качестве ключа, а не строку `«id»`.

<br>
<br>
<br>

  <h3>+ Символы игнорируются циклом for…in</h3>

  - [ ] Свойства, чьи ключи – символы, не перебираются циклом `for..in`.

  ```javascript
    const userId = Symbol("id");
    const fakeUser = {
      name: "Gena",
      age: 16,
      [userId]: "id1294_21",
    
      sayHi() {
        console.log(`Привет я ${this.name}`);
      },
    };

    // (свойства с ключом-символом нет среди перечисленных)
    for (let key in fakeUser) {
      console.log(key); // name age sayHi ----> symbol нет
    }

    // хотя прямой доступ по символу работает
    console.log(fakeUser[userId]); // id1294_21

    // Object.keys(fakeUser) - так же игнорирует Symbol
    console.log(Object.keys(fakeUser)); // [ 'name', 'age', 'sayHi' ]
  ```

  + Это – часть общего принципа «сокрытия символьных свойств». Если другая библиотека или скрипт будут работать с нашим объектом, то при переборе они не получат ненароком наше символьное свойство.
  +  `Object.keys(user)`**(выводит массив ключей объекта)** также игнорирует символы.

  <br>
  <br>

  - [x] А вот `Object.assign`, в отличие от цикла `for..in`, копирует и строковые, и символьные свойства:

  ```javascript
    const userId = Symbol("id");
    const fakeUser = {
      name: "Gena",
      age: 16,
      [userId]: "id1294_21",
    
      sayHi() {
        console.log(`Привет я ${this.name}`);
      },
    };
    
    const fakeUserCopy = Object.assign({}, fakeUser);
    
    console.log(fakeUserCopy[userId]); // id1294_21
  ```

  + Здесь нет никакого парадокса или противоречия. Так и задумано. Идея заключается в том, что, когда мы клонируем или объединяем объекты, мы обычно хотим скопировать все свойства (включая такие свойства с ключами-символами, как, например, id в примере выше).

  <br>
  <br>

  - [x] `JSON.parse(JSON.stringify(value))` - так же игнорирует `Symbol`. Ровным счетом как и игнорирует функции / методы.

<hr>
<br>
<br>

<h2>Глобальные символы</h2>

![image](https://github.com/acidshotgun/learn-js-vanilla/assets/117285472/a03e85e2-b4eb-4b03-aeed-5feb6832c517)

<br>

- [ ] Для чтения (или, при отсутствии, создания) символа из реестра используется вызов `Symbol.for(key)`.

  + Он проверяет глобальный реестр и, при наличии в нём `символа с именем key`, возвращает его, иначе же создаётся новый символ `Symbol(key)` и записывается в реестр под ключом `key`.
  + Те. это `глобальные символы` - если они есть => возвращаются, если нет => создаются. (по ключу `key`)
     
  ```javascript
    // читаем символ из глобального реестра и записываем его в переменную
    let id = Symbol.for("id"); // если символа не существует, он будет создан
    
    // читаем его снова и записываем в другую переменную (возможно, из другого места кода)
    let idAgain = Symbol.for("id");
    
    // проверяем -- это один и тот же символ
    alert( id === idAgain ); // true
  ```

  + Символы, содержащиеся в реестре, называются `глобальными символами`. Если вам нужен символ, доступный везде в коде – используйте глобальные символы.
     
<br>
<br>
<br>

  <h3>+ Symbol.keyFor</h3>

  - [ ] **`Для глобальных символов`**, кроме `Symbol.for(key)`, который ищет символ по имени, существует обратный метод: `Symbol.keyFor(sym)`, который, наоборот, `принимает глобальный символ и возвращает его имя`.

    + Именно для глобальных символов!

  ```javascript
    // получаем символ по имени
    let sym = Symbol.for("name");
    let sym2 = Symbol.for("id");
    
    // получаем имя по символу
    alert( Symbol.keyFor(sym) ); // name
    alert( Symbol.keyFor(sym2) ); // id
  ```

  + Внутри метода `Symbol.keyFor` используется глобальный реестр символов для нахождения имени символа. Так что `этот метод не будет работать для неглобальных символов`. Если символ неглобальный, метод не сможет его найти и вернёт `undefined`.

  + Впрочем, для любых символов доступно свойство `description` (есть выше).

  ```javascript
    let globalSymbol = Symbol.for("name");
    let localSymbol = Symbol("name");

    // Symbol.keyFor(value) - только для глобальных
    console.log(Symbol.keyFor(globalSymbol)); // name
    console.log(Symbol.keyFor(localSymbol)); // undefined

    // description - для всех
    console.log(globalSymbol.description); // name
    console.log(localSymbol.description); // name
  ```

<hr>
<br>
<br>

<h2>Системные символы</h2>

![image](https://github.com/acidshotgun/learn-js-vanilla/assets/117285472/dbc4f5c5-e842-47e5-bd59-e1edf8a42146)

<hr>
<br>
<br>

<h2>ИТОГО</h2>

![image](https://github.com/acidshotgun/learn-js-vanilla/assets/117285472/79ad4cf5-3c60-47d4-9e47-9b693f5e0b3d)
