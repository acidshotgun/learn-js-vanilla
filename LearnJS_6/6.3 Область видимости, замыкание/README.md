# Область видимости переменных, замыкание

<h2>Блоки кода + Влож - фии</h2>

  <h3>+ Блоки кода</h3>

  - [ ] Если переменная объявлена внутри блока кода {...}, то она видна только внутри этого блока.

  ```typescript
    {
      // Локальная переменная
      let message: string = "Hello world"; // переменная видна только в этом блоке
    
      console.log(message); // OK
    }
    
    console.log(message); // message is not defined
  ```
  
  <br>
  
  - [ ] Для `if`, `for`, `while` и т.д. переменные, объявленные в блоке кода `{...}`, также видны только внутри:
  
  ```typescript
    if (true) {
      let phrase: string = "Hello";
    
      console.log(phrase); // Hello
    }
    
    console.log(phrase); // Ошибка, нет такой переменной!
  ```

<br>

<h3>+ Вложенные функции</h3>

- [ ] Функция называется `«вложенной»`, когда она создаётся внутри другой функции.

```typescript
  function makeCounter(): () => number {
    let count: number = 0;
  
    return function (): number {
      // ф-я не находит count в своем лекс. окружении
      // Обращается к внешнему окружению + Запоминает его
      return count++; // есть доступ к внешней переменной "count"
    };
  }
  
  // В counter будет результат вызова makeCounter()
  // Т.е анонимная ф-я, возвращающая count
  let counter = makeCounter();
  
  // !!! Ф-я запоминает лексическое окружение !!!
  // Поэтому всегда имеет доступ к count - это замыкание
  console.log(counter()); // 0
  console.log(counter()); // 1
  console.log(counter()); // 2
```

<hr>
<br>
<br>

<h2>Лексическое окружение</h2>

<h3>+ Шаг 1. Переменные</h3>

![image](https://github.com/acidshotgun/learn-js-vanilla/assets/117285472/973117e1-613d-4a65-9baa-cdf513dfee41)

![image](https://github.com/acidshotgun/learn-js-vanilla/assets/117285472/e4f1c1a9-3769-4f19-aa29-d5d8a7c876cf)

<br>

+ По мере выполнения кода лексическое окружение меняется.

![image](https://github.com/acidshotgun/learn-js-vanilla/assets/117285472/71dad7b1-84a9-430c-8933-5aeedc6a3cd9)

+ Прямоугольники с правой стороны демонстрируют, как глобальное лексическое окружение изменяется в процессе выполнения кода:

  - [x] При запуске скрипта лексическое окружение предварительно заполняется всеми объявленными переменными.
  
    + Изначально они находятся в состоянии `«Uninitialized»`. Т.е. движок знает о них, но они еще не объявлены.
    + Но на нее нельзя ссылаться, пока она не будет объявлена с помощью `let`. Это почти то же самое, как если бы переменная не существовала.
       
  - [x] Появляется определение переменной `let phrase`. У неё ещё нет присвоенного значения, поэтому присваивается `undefined`. С этого момента мы можем использовать переменную.
 
  - [x] Переменной `phrase` присваивается значение.
 
  - [x] Переменная phrase меняет значение.
 
+ Доп пример

```typescript
  let name: string = "Lydia";

  function getName(): void {
    // Тут name будет найдена в локальном окружении и во внешее обращения не будет
    // Но она еще не объявлена === «Uninitialized»
    console.log(name);
    let name: string = "Some";
  }

  // Результат - переменная еще не объявлена - ошибка
  getName(); // ReferenceError: Cannot access 'name' before initialization
```

<br>
<br>

<h3>+ Шаг 2. Function Declaration</h3>

- [ ] `Функция` – это тоже значение, как и переменная.
- [ ] Разница заключается в том, что `Function Declaration` `мгновенно инициализируется полностью` (с началом кода).

  + Помним, что переменная `let` сначала находится в статусе `«Uninitialized»`, затем `undefined`, а потом уже является рабочей.
     
![image](https://github.com/acidshotgun/learn-js-vanilla/assets/117285472/c52648fd-8525-45f8-ad8e-fe70431e5334)
     
<br>

- [x] **Это кстати объясняет то, что `Function Declaration` может быть вызвана до объявления. Она инициализируется сразу с началом кода.**

<br>
<br>

<h3>+ Шаг 3. Внутреннее и внешнее лексическое окружение</h3>

- [ ] Когда запускается функция, в начале ее вызова автоматически создается новое `лексическое окружение` для хранения локальных переменных и параметров вызова.

<br>

+ **Когда код хочет получить доступ к переменной – сначала происходит поиск во `внутреннем лексическом окружении`, затем во `внешнем`, затем в следующем и так далее, до глобального.**

![image](https://github.com/acidshotgun/learn-js-vanilla/assets/117285472/e836647e-5a29-43b5-84b5-e4b0f29b10c6)

<br>
<br>

<h3>+ Шаг 4. Возврат функции + ЗАМЫКАНИЕ</h3>

![image](https://github.com/acidshotgun/learn-js-vanilla/assets/117285472/43cb0e2b-3ef2-44e6-a8de-a30a7a14a2b2)

<br>

- [x] `Замыкание` Способность ф-и запоминать свое внешнее лексическое окружение и обращаться к нему из любого места.

  +  Переменная обновляется в том лексическом окружении, в котором она существует.
  +  Для каждого вызова создается свое независимое лексическое окружение 

```typescript
  function makeCounter(): () => number {
    let count: number = 0;
  
    return function (): number {
      // ф-я не находит counter и обращается к внеш окружению
      // Тем самым запоминая его
      return count++;
    };
  }
  
  // Два разных вызова
  let counter = makeCounter();
  let counter2 = makeCounter();
  
  // Вызывая counter в котором лежит анонимная-я
  // Эта анонимная ф-я всегда имеет достук с count
  // Тк запомнила его - ЗАМЫКАНИЕ
  console.log(counter()); // 0
  console.log(counter()); // 1
  console.log(counter()); // 2
  
  // Для каждого вызова создается свое независимое лексическое окружение
  // И меняться зн-я будут только в своем лексическом окружении
  console.log(counter2()); // 0
  console.log(counter2()); // 1
  console.log(counter2()); // 2
```
