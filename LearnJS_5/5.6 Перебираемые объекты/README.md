# Перебираемые объекты

- [ ] `Перебираемые (или итерируемые) объекты` – это обобщение массивов. Концепция, которая позволяет использовать любой объект в цикле `for..of`. (По-умолчанию объекты перебирать нельзя!! В отличии от массивов)

- [ ] Если объект не является массивом, но представляет собой коллекцию каких-то элементов (список, набор), то удобно использовать цикл `for..of` для их перебора.

<hr>
<br>
<br>

<h2>Symbol.iterator</h2>

- [ ] Пример:

  + Например, у нас есть объект. Это не массив, но он выглядит подходящим для `for..of`.

```javascript
  let range = {
    from: 1,
    to: 5
  };
  
  // Мы хотим, чтобы работал for..of:
  // for(let num of range) ... num=1,2,3,4,5
```

- [ ] Чтобы сделать range итерируемым (и позволить `for..of` работать с ним), нам нужно добавить в объект метод с именем `Symbol.iterator` (специальный встроенный `Symbol`, созданный как раз для этого).

  + Когда цикл `for..of` запускается, он вызывает этот метод один раз (или выдаёт ошибку, если метод не найден). Этот метод должен вернуть итератор – объект с методом `next`.
  + Дальше `for..of` работает только с этим возвращённым объектом.
  + Когда `for..of` хочет получить следующее значение, он вызывает метод `next()` этого объекта.
  + Результат вызова `next()` должен иметь вид `{done: Boolean, value: any}`, где `done=true` означает, что цикл завершён, в противном случае `value` содержит очередное значение.
     
```javascript
  let range = {
    from: 1,
    to: 5,
}

let range = {
  from: 1,
  to: 5
};

// 1. вызов for..of сначала вызывает эту функцию
range[Symbol.iterator] = function() {

  // ...она возвращает объект итератора:
  // 2. Далее, for..of работает только с этим итератором,
  // запрашивая у него новые значения
  return {
    current: this.from,
    last: this.to,

    // 3. next() вызывается на каждой итерации цикла for..of
    next() {
      // 4. он должен вернуть значение в виде объекта {done:.., value :...}
      if (this.current <= this.last) {
        return { done: false, value: this.current++ };
      } else {
        return { done: true };
      }
    }
  };
};

// теперь работает!
for (let num of range) {
  alert(num); // 1, затем 2, 3, 4, 5
}

// Теперь можем перебрать объект при помощи for of
for (let key of range) {
  console.log(key);
}
```

- [ ] Обратите внимание на ключевую особенность итераторов: `разделение ответственности`.

  +  У самого объекта range нет метода `next()`.
  +  Вместо этого другой объект, так называемый «итератор», создаётся вызовом `range[Symbol.iterator]()`, и именно его `next()` генерирует значения.
     
- [x] Технически мы можем объединить их и использовать сам range как итератор, чтобы упростить код.

```javascript
  let range = {
    from: 1,
    to: 5,
  
    [Symbol.iterator]() {
      this.current = this.from;
      return this;
    },
  
    next() {
      if (this.current <= this.to) {
        return { done: false, value: this.current++ };
      } else {
        return { done: true };
      }
    }
  };
  
  for (let num of range) {
    alert(num); // 1, затем 2, 3, 4, 5
  }
```

- [ ] Теперь `range[Symbol.iterator]()` возвращает сам объект range: у него есть необходимый метод `next()`, и он запоминает текущее состояние итерации в `this.current`

  + Недостаток такого подхода в том, что теперь мы не можем использовать этот объект в двух параллельных циклах `for..of`: у них будет общее текущее состояние итерации, потому что теперь существует лишь один итератор – сам объект. Но необходимость в двух циклах `for..of`, выполняемых одновременно, возникает редко, даже при наличии асинхронных операций.
     
<hr>
<br>
<br>

<h2>Строка – перебираемый объект</h2>

![image](https://github.com/acidshotgun/learn-js-vanilla/assets/117285472/0ed428f9-1176-4b33-a2a7-26d74386400e)

<hr>
<br>
<br>

<h2>Итерируемые объекты и псевдомассивы</h2>

- [x] `Итерируемые объекты` – это объекты, которые реализуют метод `Symbol.iterator`, как было описано выше.
- [x] `Псевдомассивы` – это объекты, у которых есть индексы и свойство `length`, то есть, `они выглядят как массивы`.

  ![image](https://github.com/acidshotgun/learn-js-vanilla/assets/117285472/d3c13745-30d6-457c-882b-17b568d568c7)

<hr>
<br>
<br>

<h2>Array.from</h2>     

- [ ] Есть универсальный метод `Array.from`, который принимает `итерируемый объект` или `псевдомассив` и делает из него «настоящий» `Array`. После этого мы уже можем использовать методы массивов.

```javascript
  const obj = {
    0: "Hello",
    1: "World",
    2: "Debili",
    length: 3,
  };
  
  const arr = Array.from(obj); // делаем массив из псевдомассива
  
  arr.push("ZHOPA"); // Можем юзать метод массиво
  
  for (let key of arr) {
    console.log(key); // Hello World Debili ZHOPA
  }
```

- [ ] То же самое происходит с `итерируемым объектом`:

```javascript
  let range = {
    from: 1,
    to: 5,
  
    [Symbol.iterator]() {
      this.current = this.from;
      return this;
    },
  
    next() {
      if (this.current <= this.to) {
        return { done: false, value: this.current++ };
      } else {
        return { done: true };
      }
    },
  };
  
  let newArr = Array.from(range); // Делаем массив из итеррируемого объекта
  
  newArr.push("НОВЫЙ ЭЛЕМЕНТ"); // помещаем элемент в конец
  
  console.log(newArr); // [ 1, 2, 3, 4, 5, 'НОВЫЙ ЭЛЕМЕНТ' ]
  
  for (let key of newArr) {
    console.log(key); // 1, 2, 3, 4, 5, 'НОВЫЙ ЭЛЕМЕНТ' 
  }
```

<br>

+ Важно что с обычным объектом такое не прокатит

```javascript
  let test = {
    0: "привет",
    1: "мир",
  };
  
  let newArray2 = Array.from(test);
  
  console.log(newArray2); // []
```
