# Массивы 

- [x] `Массивы` - это структура, в которой данные хранятся по порядку.
- [ ] Так же массивы предоставляют методы для управления порядком элементов.

<br>

  + `Массив` - это тот же объект, только в кач-ве ключей св-ва использует порядковые номера.

```javascript
  // Два синтаксиса объявления массивов

  let arr = new Array();
  let arr = []; // Используется чаще всего.
```

```javascript
  let fruits = ["Яблоко", "Апельсин", "Слива"];
  console.log(fruits); // [ 'Яблоко', 'Апельсин', 'Слива' ]
  
  // Получаем элементы по номеру в []
  console.log(fruits[0]); // Яблоко
  console.log(fruits[1]); // Апельсин
  console.log(fruits[2]); // Слива
  
  // Изменим какое-то зн-е
  fruits[1] = "ЗАМЕНИЛИ ЗНАЧЕНИЕ";
  console.log(fruits); // [ 'Яблоко', 'ЗАМЕНИЛИ ЗНАЧЕНИЕ', 'Слива' ]
  
  // Добавим новое зн-е
  fruits[3] = "Новое значение";
  console.log(fruits); // [ 'Яблоко', 'ЗАМЕНИЛИ ЗНАЧЕНИЕ', 'Слива', 'Новое значение' ]
  
  // Получим длину массива - св-во length
  console.log(fruits.length); // 4
```

+ Можно разные типы данных

```javascript
  // разные типы значений
  let arr = ["Яблоко", { name: "Джон" }, true,function () {console.log("привет");},];
  
  // получить элемент с индексом 1 (объект) и затем показать его свойство
  console.log(arr[1].name); // Джон
  
  // получить элемент с индексом 3 (функция) и выполнить её
  arr[3](); // привет
```

<hr>
<br>
<br>

<h2>Получение последних элементов при помощи «at»</h2>

- [ ] Получение последнего элемента / элемента с конца работает по принципу как и у строк (если зн-е отрицательное).

```javascript
  let fruits = ["Яблоко", "Апельсин", "Слива"];
  
  console.log(fruits[fruits.length - 1]); // Слива
  
  console.log(fruits[-1]); // undefined
  
  console.log(fruits.at(-2)); // Апельсин
```

<hr>
<br>
<br>

<h2>Методы pop/push, shift/unshift</h2>

- [ ] Одни из самых распросраненных операций с массивами - это `очередь` - ( первый пришёл — первый вышел ) и `стек` - ( «последним пришёл — первым вышел» )

  + `push(...items)` добавляет items в конец массива. (можно несколько(
  + `pop()` удаляет элемент в конце массива и возвращает его.
  + `shift()` удаляет элемент в начале массива и возвращает его. (сдвигает массив)
  + `unshift(...items)` добавляет items в начало массива. (сдвигает массив) (можно несколько)
     
  <br>

  + Метода, работающие с началом массива:
     
    ```javascript
      // arr.pop()
      let fruits = ["Яблоко", "Апельсин", "Слива"];
      
      fruits.pop(); // Слива
      
      console.log(fruits); // [ 'Яблоко', 'Апельсин' ]
      
      
      // arr.push()
      fruits.push("АНАНАС")
      
      console.log(fruits) // [ 'Яблоко', 'Апельсин', 'АНАНАС' ]
    ```

  <br>

  + Метода, работающие с концом массива:
     
    ```javascript
      // arr.shift() удаляет первый и возвращает его (сдвигает массив)
      let fruits = ["Яблоко", "Апельсин", "Слива"];
      
      fruits.shift(); // Яблоко
      
      console.log(fruits); // [ 'Апельсин', 'Слива' ]
      
      
      // arr.unshift() - добавляет в начало (сдвигает массив)
      fruits.unshift("АНАНАС", "бензин");
      
      console.log(fruits); // [ 'АНАНАС', 'бензин', 'Апельсин', 'Слива' ]
    ```

<hr>
<br>
<br>

<h2>Внутреннее устройство массива</h2>

![image](https://github.com/acidshotgun/learn-js-vanilla/assets/117285472/5382eb2e-8302-47e9-8f5a-da079ea088c2)

- [x] Особенность массивов - это JavaScript старается хранить элементы массива в непрерывной области памяти, один за другим.
- [ ] Но эффективность будет утрачена если мы перестанем работать с массивом как с «упорядоченной коллекцией данных» и начнём использовать его как обычный объект.

    + Например, технически мы можем сделать следующее:
     
    ```javascript
      let fruits = []; // создаём массив

      fruits[99999] = 5; // создаём свойство с индексом, намного превышающим длину массива
      
      fruits.age = 25; // создаём свойство с произвольным именем
      
      console.log(fruits); // [ <99999 empty items>, 5, age: 25 ]
      console.log(fruits.age); // 25
    ```

    + Это возможно, потому что в основе массива лежит объект.
     
    ![image](https://github.com/acidshotgun/learn-js-vanilla/assets/117285472/9d67c864-e81a-4335-93b9-0d964437b9f5)

<hr>
<br>
<br>

<h2>Перебор элементов</h2>

- [x] Массив можно перебрать двумя способами:

  + Цикл `for`
  + Цикл `for of` - выводит значения массива.
     
  ```javascript
    let arr = ["Яблоко", "Апельсин", "Груша"];

    for (let i = 0; i < arr.length; i++) {
      console.log(arr[i]); // Яблоко, Апельсин, Груша
    }
    
    for (let key of arr) {
      console.log(key); // Яблоко, Апельсин, Груша
    }
  ```

<br>

![image](https://github.com/acidshotgun/learn-js-vanilla/assets/117285472/be884e69-b0db-4579-b9ad-5741b9b8ce01)

<hr>
<br>
<br>

<h2>Немного о «length»</h2>

- [ ] Длина массива - по сути это не его длина, а индекс последнего элемента.

```javascript
  let fruits = [];

  // Индексу 123 присваиваем строку Яблоко
  fruits[123] = "Яблоко";
  
  console.log(fruits.length); // Длина всего массива будет 124
  // Но  пр этом будет 123 пустых элемента
```

<br>

- [x] `length` – его можно перезаписать.
- [ ] Если мы вручную увеличим его, ничего интересного не произойдёт. Зато, если мы уменьшим его, массив станет короче

```javascript
  let arr = [1, 2, 3, 4, 5];

  arr.length = 2; // укорачиваем до двух элементов
  console.log( arr ); // [1, 2]
  
  arr.length = 5; // возвращаем length как было
  console.log( arr[3] ); // undefined: значения не восстановились
```

<br>

- [x] Таким образом, самый простой способ очистить массив – это `arr.length = 0;`.

<hr>
<br>
<br>

<h2>new Array()</h2>

```javascript
  let arr = new Array("Яблоко", "Груша", "и тд");
```

<br>

+ Особенность - если `new Array()` вызывается с одним аргументом и это `число (n)` => будет создан массив длины (n) с `undefined` св-ми.

```javascript
  const arr = new Array(10);

  console.log(arr[3]); // undefined - (пусто)
  console.log(arr); // [ <10 empty items> ] - (10 пустых элементов)
  console.log(arr.length); // Длинна массива - 10
```

<hr>
<br>
<br>

<h2>toString</h2>

- [ ] Массивы по-своему реализуют метод `toString`, который возвращает список элементов, разделённых запятыми.

```javascript
  let arr = [1, 2, 3];
  
  alert( arr ); // 1,2,3
  alert( String(arr) === '1,2,3' ); // true
```

```javascript
  alert( [] + 1 ); // "1"
  alert( [1] + 1 ); // "11"
  alert( [1,2] + 1 ); // "1,21"
```

- [x] Массивы не имеют ни `Symbol.toPrimitive`, ни функционирующего `valueOf`, они реализуют только преобразование `toString`, таким образом, здесь [] становится пустой строкой, [1] становится "1", а [1,2] становится "1,2".

  + В отличии от объектов, где по умолчанию, нет преобразования и преобразование в строку даст `[object Object]` и `toString()` нужно прописывать отдельно.
     
<hr>
<br>
<br>

<h2>Не сравнивайте массивы при помощи ==</h2>

- [ ] Массивы ведут себя как объекты, соответственно равны друг другу, если переменная ссылается на один и тот же массив в памяти.
- [ ] Помним, что разные объекты никогда не равны друг - другу. (только если одна ссылка)

![image](https://github.com/acidshotgun/learn-js-vanilla/assets/117285472/ba50f916-20db-40d5-ab8b-77a339436e19)

```javascript
  const arr = ["привет", "как дела?", 10];

  // const arr2 = ["привет", "как дела?", 10]; // тут false (разные объекты)
  
  const arr2 = arr; // тут true (ссылка)
```
![image](https://github.com/acidshotgun/learn-js-vanilla/assets/117285472/9ad10be2-a560-48d4-8ac6-a5f85b0ec2ab)

<br>

- [x] Таким образом, чтобы сравнить массивы - их нужно перебрать при помощи цикла или методы итерации.
